<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Pwn（1-1-1）学习地址：PWN入门（1-1-1）-C函数调用过程原理及函数栈帧分析（Intel） 栈（stack）栈是计算机内存中的一种区域，用于存储函数调用相关的数据，包括局部变量、函数参数和返回地址。 我理解为一个弹夹，最后压进去的子弹反而会第一个弹出，push操作就是压子弹，pop操作就是弹出子弹到枪膛（寄存器or内存）里，但是栈有大小限制，总容量是系统级固定值（可通过ulimit等命">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2025/11/28/Pwn%EF%BC%88%E6%A0%88%EF%BC%89/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Pwn（1-1-1）学习地址：PWN入门（1-1-1）-C函数调用过程原理及函数栈帧分析（Intel） 栈（stack）栈是计算机内存中的一种区域，用于存储函数调用相关的数据，包括局部变量、函数参数和返回地址。 我理解为一个弹夹，最后压进去的子弹反而会第一个弹出，push操作就是压子弹，pop操作就是弹出子弹到枪膛（寄存器or内存）里，但是栈有大小限制，总容量是系统级固定值（可通过ulimit等命">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/picture/stack/%E6%A0%88push1.jpg">
<meta property="og:image" content="http://example.com/picture/stack/%E6%A0%88push2.jpg">
<meta property="og:image" content="http://example.com/picture/stack/%E6%A0%88pop1.jpg">
<meta property="og:image" content="http://example.com/picture/stack/%E6%A0%88pop2.jpg">
<meta property="og:image" content="http://example.com/picture/stack/%E6%A0%88%E5%B8%A7%E7%A4%BA%E4%BE%8B2.jpg">
<meta property="og:image" content="http://example.com/picture/stack/%E6%A0%88%E5%B8%A7%E7%A4%BA%E4%BE%8B1.jpg">
<meta property="og:image" content="http://example.com/picture/stack/1st.jpg">
<meta property="og:image" content="http://example.com/picture/stack/2nd.png">
<meta property="og:image" content="http://example.com/picture/stack/3rd.png">
<meta property="og:image" content="http://example.com/picture/stack/4th.png">
<meta property="og:image" content="http://example.com/picture/stack/5th.png">
<meta property="og:image" content="http://example.com/picture/stack/6th.png">
<meta property="og:image" content="http://example.com/picture/stack/7th.png">
<meta property="og:image" content="http://example.com/picture/stack/8th.png">
<meta property="og:image" content="http://example.com/picture/stack/9th.png">
<meta property="og:image" content="http://example.com/picture/stack/10th.png">
<meta property="article:published_time" content="2025-11-28T13:03:17.457Z">
<meta property="article:modified_time" content="2025-12-02T13:04:24.146Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/picture/stack/%E6%A0%88push1.jpg">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 8.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Pwn（栈）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/11/28/Pwn%EF%BC%88%E6%A0%88%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2025-11-28T13:03:17.457Z" itemprop="datePublished">2025-11-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Pwn（1-1-1）"><a href="#Pwn（1-1-1）" class="headerlink" title="Pwn（1-1-1）"></a>Pwn（1-1-1）</h1><p>学习地址：<a target="_blank" rel="noopener" href="https://www.yuque.com/cyberangel/rg9gdm/gcz7x2">PWN入门（1-1-1）-C函数调用过程原理及函数栈帧分析（Intel）</a></p>
<h2 id="栈（stack）"><a href="#栈（stack）" class="headerlink" title="栈（stack）"></a>栈（stack）</h2><p><strong>栈</strong>是计算机内存中的一种区域，用于存储函数调用相关的数据，包括局部变量、函数参数和返回地址。</p>
<p>我理解为一个弹夹，最后压进去的子弹反而会第一个弹出，push操作就是压子弹，pop操作就是弹出子弹到枪膛（寄存器or内存）里，但是栈有大小限制，总容量是系统级固定值（可通过<code>ulimit</code>等命令调整），通常为8MB（Linux系统），超出可能会触发栈溢出（Stack Overflow）漏洞。（像子弹多弹出一颗到枪膛内，就很危险，容易走火）</p>
<p>push操作图例：<code>push 0x50	//将0x50压入栈中；</code></p>
<p><img src="/../../picture/stack/%E6%A0%88push1.jpg" alt="栈push1">							<img src="/../../picture/stack/%E6%A0%88push2.jpg" alt="栈push2"></p>
<p>pop操作图例：<code>pop 寄存器名称	//将栈中的0x50弹出到指定寄存器中；</code></p>
<p><img src="/../../picture/stack/%E6%A0%88pop1.jpg" alt="栈pop1">							<img src="/../../picture/stack/%E6%A0%88pop2.jpg" alt="栈pop2"></p>
<p>图中，蓝色为已写入数据的区域，绿色为还未写入数据区域；（图片使用<a target="_blank" rel="noopener" href="https://app.diagrams.net/?src=about">draw.io</a>制作）</p>
<p>知识点：</p>
<p>1、以上例子中的栈的生长方向从<strong>高地址到低地址</strong>，即图中的向下生长；</p>
<p>2、示例为x86-32bit系统，所以寄存器的宽度为4字节，对应到图中就是每个格子都是一个4字节的内存区域，所以上下两个地址之间相差4；</p>
<p>3、SP（栈指针）每个栈一个，固定指向<strong>当前栈</strong>的<strong>栈顶</strong>；</p>
<p>4、SP指针未指向的数据需要<strong>间接读取</strong>，但是栈顶与非栈顶的数据并无本质区别，栈的本质是进程的<strong>连续可读写内存</strong>，不管是栈顶还是非栈顶，只要在栈空间范围内，核心数据操作权限完全一致；</p>
<h2 id="栈帧（stack-frame）"><a href="#栈帧（stack-frame）" class="headerlink" title="栈帧（stack frame）"></a>栈帧（stack frame）</h2><p>也叫 “过程活动记录”，其本质就是一种栈，只是这种栈专门用于保存函数调用过程中的各种信息（参数，返回地址，本地变量等），是函数调用时在栈上<strong>单独分配</strong>的一段内存单元，每个函数调用对应一个独立栈帧。函数调用时，栈帧被压入栈内，函数执行结束后弹出（把一个栈帧看成上面的0x50就能理解了）</p>
<p>单个栈帧的占栈空间极小部分（几字节到几KB），但是同一时间，所有正在执行的函数（调用栈）的栈帧总和，不能超过栈的总大小，否则会触发栈溢出，就像临时压子弹压多了，即使后面会打出去（栈帧弹出），也算溢出。</p>
<p>栈帧示例：前一张是引用文章的图片，后一张为我重制了一下的图片；</p>
<p><img src="/../../picture/stack/%E6%A0%88%E5%B8%A7%E7%A4%BA%E4%BE%8B2.jpg" alt="栈帧示例2">	<img src="/../../picture/stack/%E6%A0%88%E5%B8%A7%E7%A4%BA%E4%BE%8B1.jpg" alt="栈帧示例1"></p>
<p>知识点：假设调用者栈帧为funcA，被调用者栈帧为funcB；</p>
<p>1、<strong>函数参数</strong>：就像C语言中在main函数外面写了其他函数后被main函数调用一样，funcA运行到一半，call到funcB那里去了，比如下面第一行就是funcB(0x50)，然后0x50被转去funcB那里去运算，此处0x50就是<strong>函数参数</strong>（不包括push），如果要传多个参数，就有多个函数参数的蓝色（右）块块；</p>
<p>–注：多个参数时，最下面的参数第一个被弹出，所以最下面的参数是第一个参数；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x08048400:  push   0x50          ; 压入被调用函数的参数（假设）</span><br><span class="line">0x08048402:  call   0x08048450    ; 调用被调用函数（地址0x08048450）</span><br><span class="line">0x08048407:  mov    eax, 0x0      ; call指令的下一条指令（执行完被调用函数后要回到这里）</span><br></pre></td></tr></table></figure>

<p>2、<strong>返回地址</strong>：上面代码的0x08048407就是“返回地址”，也就是说，上面的第三行代码就是右图中的“返回地址”蓝块块，意为执行完funcB后返回，继续运行的地方；</p>
<p>–注：由于偷懒，“返回地址”的蓝块块下方应该还有funcA的后续操作才对，懒得补了，此处解释就算了（诶嘿）；</p>
<p>3、<strong>旧EBP</strong>：左图的“旧的%ebp”很容易误导人啊，它的意思是，这个绿块块（左）里面存的是旧的EBP，而不是说这个绿块块本身是旧的EBP；右图比较详细，0x118存的应该是funcA的旧EBP，对应右图就是0x12C（旧的EBP(A))；作用是调用完后快速定位原本的栈帧，没有旧EBP的话可能把更早的栈帧也当成是funcA了；</p>
<p>4、<strong>间接读取</strong>：根据指针的位置计算要去的位置的偏移量，可以是<code>[esp±偏移量]</code>（SP经常动，多用于临时访问，不稳定），也可用<code>[ebp±偏移量]</code>（除非栈帧变更，否则ebp不变，相对稳定）；</p>
<p>–注：根据32位或者64位，偏移量是4或8的倍数，也就是我以前写exp时，偏移量经常要乘8的原因（终于明白了）；</p>
<h2 id="指针（SP、BP）"><a href="#指针（SP、BP）" class="headerlink" title="指针（SP、BP）"></a>指针（SP、BP）</h2><p>按寄存器分32位和64位，以下先对两种的不同进行整理，为了方便<del>（懒）</del>，以下还是都以32位为例。</p>
<table>
<thead>
<tr>
<th>对比维度</th>
<th>32 位指针</th>
<th align="left">64 位指针</th>
</tr>
</thead>
<tbody><tr>
<td>指针长度</td>
<td>占 4 字节（32 位）</td>
<td align="left">占 8 字节（64 位）</td>
</tr>
<tr>
<td>栈 &#x2F; 帧指针名字</td>
<td>栈指针 &#x3D; ESP，帧指针 &#x3D; EBP</td>
<td align="left">栈指针 &#x3D; RSP，帧指针 &#x3D; RBP</td>
</tr>
<tr>
<td>寄存器前缀</td>
<td>对应 32 位寄存器（如 EAX、EBX）</td>
<td align="left">对应 64 位寄存器（如 RAX、RBX）</td>
</tr>
<tr>
<td>地址空间上限</td>
<td>最大访问 4GB 内存（2³² 字节）</td>
<td align="left">理论最大访问 16EB（2⁶⁴字节），实际系统（如 Windows）通常限制为 256TB 左右</td>
</tr>
<tr>
<td>适用架构</td>
<td>x86（32 位）处理器 &#x2F; 操作系统</td>
<td align="left">x86-64（64 位）处理器 &#x2F; 操作系统</td>
</tr>
</tbody></table>
<h3 id="指针分类"><a href="#指针分类" class="headerlink" title="指针分类"></a>指针分类</h3><p>栈中的指针（SP栈指针）与普通指针变量（C语言）</p>
<table>
<thead>
<tr>
<th>对比维度</th>
<th>SP（栈指针）</th>
<th>普通指针变量（如 C 语言<code>int *p</code>）</th>
</tr>
</thead>
<tbody><tr>
<td>存储位置</td>
<td>CPU 寄存器（ESP&#x2F;RSP）</td>
<td>内存（栈 &#x2F; 堆）</td>
</tr>
<tr>
<td>核心内容</td>
<td>栈顶的内存地址（指针值）</td>
<td>目标数据的内存地址（指针值）</td>
</tr>
<tr>
<td>功能角色</td>
<td>栈指针（管理栈顶）</td>
<td>普通数据指针（访问内存数据）</td>
</tr>
<tr>
<td>访问速度</td>
<td>极快（CPU 内部直接访问）</td>
<td>较慢（需访问内存）</td>
</tr>
<tr>
<td>专属属性</td>
<td>CPU 硬件级支持（push&#x2F;pop 自动改 SP 值）</td>
<td>软件层面定义（需手动赋值 &#x2F; 解引用）</td>
</tr>
</tbody></table>
<p>SP（栈指针）与EBP（帧指针）</p>
<table>
<thead>
<tr>
<th>对比维度</th>
<th>SP（栈指针）</th>
<th>EBP（帧指针）</th>
</tr>
</thead>
<tbody><tr>
<td>概念定义</td>
<td>CPU 寄存器，始终指向<strong>当前栈的栈顶</strong>位置</td>
<td>CPU 寄存器，始终指向<strong>当前栈帧的底部（基址）</strong></td>
</tr>
<tr>
<td>核心作用</td>
<td>管理栈顶位置，<code>push/pop</code>操作、函数调用时会自动移动 SP</td>
<td>定位当前栈帧内的局部变量、函数参数（通过 “EBP + 偏移量” 访问）</td>
</tr>
<tr>
<td>所属范围</td>
<td>整个栈（全局管理栈的栈顶，不随栈帧切换而独立存在）</td>
<td>单个栈帧（每个栈帧对应一个 EBP 值，函数调用时会保存旧 EBP）</td>
</tr>
<tr>
<td>x86 对应寄存器</td>
<td>32 位→ESP；64 位→RSP</td>
<td>32 位→EBP；64 位→RBP</td>
</tr>
<tr>
<td>与函数调用的关系</td>
<td>函数调用时，<code>push参数/返回地址</code>会让 SP 减小；函数内分配局部变量也会调整 SP</td>
<td>函数调用时，先保存旧 EBP，再将当前 SP 赋值给 EBP，作为当前栈帧的基址</td>
</tr>
</tbody></table>
<h3 id="栈中的指针概念"><a href="#栈中的指针概念" class="headerlink" title="栈中的指针概念"></a><u>栈中的</u>指针概念</h3><p>（以下以SP（栈指针）举例）</p>
<p>首先，SP<strong>本质</strong>是寄存器（CPU的抽屉，内存就是衣柜，寄存器的读取速度远快于内存），一个专门用来管理栈顶的专用寄存器，这是SP的硬件概念；其次，SP的<strong>功能</strong>作用是存储栈顶的内存地址，像一根指向栈顶的针，所以是“指针”。</p>
<p>在专用放快递的快递柜（寄存器）中，SP 就是标着 “栈顶地址” 的那个格子（寄存器），放的是 “栈顶在内存中的门牌号”（内存地址）—— 因此这个格子（SP 寄存器）的功能就是 “栈指针”。</p>
<h2 id="总示例"><a href="#总示例" class="headerlink" title="总示例"></a>总示例</h2><p>代码段指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">0x08048400:  main					;main 函数入口		——&gt;</span><br><span class="line">0x08048400:	 push	 ebp			;main 函数初始化栈帧（非必须，但演示完整）</span><br><span class="line">0x08048401:	 mov	 ebp, esp		;设 main 的 EBP=ESP（main 栈帧基址）</span><br><span class="line">0x08048403:	 push 	 0x14			;压入 add 的第二个参数 20（0x14）（cdecl 从右到左压参）</span><br><span class="line">0x08048408:	 push	 0x0a			;压入 add 的第一个参数 10（0x0a）</span><br><span class="line">0x0804840d:	 call	 0x08048450		;调用 add 函数，自动压入返回地址</span><br><span class="line">0x08048412:	 mov 	 eax, 0x0		;call 的下一条指令（返回地址指向这里）</span><br><span class="line">0x08048417:	 pop 	 ebp			;销毁 main 栈帧</span><br><span class="line">0x08048418:	 ret 					;main函数返回</span><br><span class="line">-----------------------------------------------------------------------------------</span><br><span class="line">0x08048450:	 add 					;add函数入口（被调用函数）</span><br><span class="line">0x08048450:	 push 	 ebp			;保存 main 的 EBP（旧 EBP）到栈</span><br><span class="line">0x08048451:	 mov	 ebp, esp		;设 add 的 EBP=ESP（add 栈帧基址）</span><br><span class="line">0x08048453:	 mov	 eax, [ebp+8]	;读取 add 第一个参数 10（EBP+8）到 EAX</span><br><span class="line">0x08048456:	 add	 eax, [ebp+12]	;EAX += 第二个参数 20 → EAX=30</span><br><span class="line">0x08048459:	 pop 	 ebp			;恢复 main 的 EBP（从栈中弹出旧 EBP）</span><br><span class="line">0x0804845a:	 ret					;弹出返回地址，跳回 main 继续执行</span><br></pre></td></tr></table></figure>

<p>指令意义：main()调用add(10,20)，即计算10+20；以下为其C语言代码示例；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>					</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;				<span class="comment">//被调用函数，对应add函数；</span></span><br><span class="line">    <span class="keyword">return</span> a + b;					<span class="comment">//对应mov eax, [ebp+8]和add eax, [ebp+12]两行；</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;						<span class="comment">//调用者函数，对应main函数；</span></span><br><span class="line">    <span class="type">int</span> num = add(<span class="number">10</span>,<span class="number">20</span>);			<span class="comment">//两个参数，对应push 0x0a和push 0x14，注意参数的特殊先后</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;						<span class="comment">//main函数返回0，对应mov eax, 0x0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>[ebp+8]</code>和<code>[ebp+12]</code>就是栈帧部分提及的间接读取，通过<code>[ebp±偏移量]</code>读取非栈顶数据；</p>
<p>栈帧布局：以下是下面代码段的<code>call 0x08048450</code>执行后、add 函数刚进入时的栈状态，标注<strong>栈地址、内容、归属、寄存器值</strong>；</p>
<table>
<thead>
<tr>
<th>栈地址</th>
<th>存储内容</th>
<th>归属 &#x2F; 说明</th>
<th>寄存器状态</th>
</tr>
</thead>
<tbody><tr>
<td>0xffffd000</td>
<td>空</td>
<td>无</td>
<td>—</td>
</tr>
<tr>
<td>0xffffcffc</td>
<td>main 的旧 EBP（0x00）</td>
<td>main 栈帧（初始化时压入，无实际意义）</td>
<td>ESP &#x3D; 0xffffcfec（栈顶）</td>
</tr>
<tr>
<td>0xffffcff8</td>
<td>add 的第二个参数：20</td>
<td>main 栈帧（调用者参数区）</td>
<td>EBP（main）&#x3D; 0xffffcffc</td>
</tr>
<tr>
<td>0xffffcff4</td>
<td>add 的第一个参数：10</td>
<td>main 栈帧（调用者参数区）</td>
<td>—</td>
</tr>
<tr>
<td>0xffffcff0</td>
<td>返回地址：0x08048412</td>
<td>栈帧分界（call 指令压入）</td>
<td>—</td>
</tr>
<tr>
<td>0xffffcfec</td>
<td>旧 EBP：0xffffcffc</td>
<td>add 栈帧（push ebp 压入，即 main 的 EBP）</td>
<td>EBP（add）&#x3D; 0xffffcfec</td>
</tr>
<tr>
<td>0xffffcfe8</td>
<td>空（add 局部变量区）</td>
<td>add 栈帧（ESP 指向这里）</td>
<td>—</td>
</tr>
</tbody></table>
<p>以下是栈的完整变化：</p>
<p><img src="/../../picture/stack/1st.jpg" alt="1st">						<img src="/../../picture/stack/2nd.png" alt="2nd"></p>
<p>图1：此时，EBP为0x00000000，所谓的更早的栈帧的EBP，但是没有更早的栈帧，所以无意义；</p>
<p>图2：ESP先减4，再push ebp把上一个EBP（所谓的旧的EBP）压入栈中；</p>
<p>图3：令<code>ebp</code>&#x3D;<code>esp</code>&#x3D;0xffffcffc（确定main栈帧的基址指针）；</p>
<p>图4：压入参数20和10（记得先把ESP减4）；</p>
<p><img src="/../../picture/stack/3rd.png" alt="3rd">				<img src="/../../picture/stack/4th.png" alt="4th"></p>
<p><img src="/../../picture/stack/5th.png" alt="5th">							<img src="/../../picture/stack/6th.png" alt="6th"></p>
<p>图5：call后自动压入返回地址，即call的下一行；</p>
<p>图6：add函数的push ebp，把main的ebp压入栈中；</p>
<p>图7：把当前的ESP位置设为add的EBP；</p>
<p>​		之后：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x08048453:	 mov	 eax, [ebp+8]	;读取 add 第一个参数 10（EBP+8）到 EAX</span><br><span class="line">0x08048456:	 add	 eax, [ebp+12]	;EAX += 第二个参数 20 → EAX=30</span><br></pre></td></tr></table></figure>

<p>​		通过 EBP+8 访问 add 第一个参数（ebp+0 &#x3D; 旧 EBP，ebp+4 &#x3D; 返回地址，ebp+8 &#x3D; 第一个参数）；</p>
<p>寄存器<code>EAX</code>&#x3D;20；</p>
<p>​		再通过 EBP+12 访问 add 第二个参数，计算结果存入 EAX（x86 默认返回值寄存器）；</p>
<p>寄存器<code>EAX</code>&#x3D;20+10&#x3D;30;</p>
<p>图8：弹出main的EBP；</p>
<p>​		此时，ESP &#x3D; ESP + 4 &#x3D; 0xffffcff0；EBP &#x3D; 弹出值 &#x3D; 0xffffcffc（恢复为 main 的 EBP）；</p>
<p><img src="/../../picture/stack/7th.png" alt="7th">				<img src="/../../picture/stack/8th.png" alt="8th"></p>
<p><img src="/../../picture/stack/9th.png" alt="9th">							<img src="/../../picture/stack/10th.png" alt="10th"></p>
<p>图9：弹出返回地址（0x08048412）；</p>
<p>​		ESP &#x3D; ESP + 4 &#x3D; 0xffffcff4；EBP &#x3D;0xffffcffc；程序跳转到0x08048412（main）；</p>
<p>图10：执行返回地址的代码；</p>
<p>​		此时，EAX&#x3D;0x00000000（就是0），main准备返回0；最后main的pop和ret同add一样，只是没有了返回，main的销毁表示main栈帧的结束；</p>
<p>知识点：</p>
<ol>
<li><strong>增长方向</strong>：栈始终向下增长（表现为ESP-4），所有<code>push</code>&#x2F;<code>call</code>均先移 ESP 再写数据；</li>
<li><strong>锚点作用</strong>：<code>mov ebp, esp</code>让 EBP 成为固定锚点（EBP±…），访问数据无需依赖 ESP 的变化；</li>
<li><strong>数据留存</strong>：栈数据 “弹出≠消失”（如 add 的旧 EBP、返回地址），仅 ESP 离开该地址，数据直到被新<code>push</code>覆盖才会消失；</li>
<li><strong>帧帧隔离</strong>：add 栈帧通过保存 main 的 EBP 实现隔离，销毁时恢复 EBP 即可回到调用者上下文；</li>
<li><strong>参数访问</strong>：add 通过<code>EBP+8/12</code>访问 main 压入的参数，体现 “帧指针 + 固定偏移” 的核心寻址逻辑。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>前前后后大概搞了三天，主要是最初的文章过于简略，而且有挺多的词和知识没有给出（比如：esp的运行过程，ebp和esp的定义与不同……），也借助了AI帮忙解释（图片是自己做的），但是也出现了自我矛盾的问题，还是挺麻烦的，还好最终算是把栈吃的差不多了，下一步是内存的分段（希望留三天可以搞定），不管了，先点杯奶茶犒劳犒劳自己，再放一两天的假！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/11/28/Pwn%EF%BC%88%E6%A0%88%EF%BC%89/" data-id="cuidikqG5cpHRmj946KQvydW7" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2025/12/20/hello-world/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Hello World
        
      </div>
    </a>
  
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/12/">December 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/11/">November 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/12/20/beginnerpwn/">beginnerpwn</a>
          </li>
        
          <li>
            <a href="/2025/12/20/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2025/11/28/Pwn%EF%BC%88%E6%A0%88%EF%BC%89/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>